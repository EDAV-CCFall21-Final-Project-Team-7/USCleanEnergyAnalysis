# Data transformation

## Financial Data
### Correcting Date format
In the dataset for oil data there were different types of date formats such as 'MM/DD/YY' and 'MM/DD/YYYY' as shown below.
```{r}
library(tidyverse)
library(kableExtra)

Crushing_crude_oil <-read_csv('data/raw/Cushing_OK_WTI_Spot_Price_FOB.csv')
head(Crushing_crude_oil,10)
```

We updated the dataset to contain dates in only one format ("MM/DD/YYYY"). This was done by splitting the date based on "/" as the delimiter. 
```{r}
str_split(Crushing_crude_oil$Day[1],"/",simplify=TRUE)
```
We then checked if the date was already in the correct format by checking the number of characters in the year component of the split. If it was not correct then we added the missing components to the year format and joined the string again while updating that in the dataframe. If the year component in the was an integer less than 22 then we added "20" before the date making the year "20xx" but if the integer was greater than 22, it is obvious that it cannot be a date from the 21th century therefore we added "19" before the date making it "19xx".

```{r}

i<-0
for(val in Crushing_crude_oil$Day){
  i<-i+1
  if(nchar(str_split(Crushing_crude_oil$Day[i],"/",simplify=TRUE)[3]) == 2){
    temp = paste(str_split(Crushing_crude_oil$Day[i],"/",simplify=TRUE)[1],
                 str_split(Crushing_crude_oil$Day[i],"/",simplify=TRUE)[2],
                 sep = "/")
    if(as.integer(str_split(Crushing_crude_oil$Day[i],"/",simplify=TRUE)[3])<22)     {
      temp2 = paste("20",
                  str_split(Crushing_crude_oil$Day[i],"/",simplify=TRUE)[3],
                  sep="")
    }
    else{
      temp2 = paste("19",
                  str_split(Crushing_crude_oil$Day[i],"/",simplify=TRUE)[3],
                  sep="")
    }
    
    Crushing_crude_oil$Day[i]<-paste(temp,temp2,sep="/")
  }
}
write.csv(Crushing_crude_oil,'data/clean/clean_crushing_crude_oil.csv',
          row.names=FALSE)
head(Crushing_crude_oil,10)
```


## Worldbank Data
### Cleaning Data 
The worldbank dataset contains extra columns that are of not any use for the purpose of this project such as the 'country name', 'country code', and 'series code'. This is because we are looking at only one country and the 'Series Name' represents the same information series code would represent. It should also be noted that the column names for the years are redundantly long and it repeats the same things. The missing cells in the dataframe are filling with a string and they need to be replaced by NA so that they appear as missing data. The table below shows the raw data before any processing.
```{r} 
worldbank <-read_csv('data/raw/US_Country_Data_WorldBank.csv') 
worldbank %>% kable(escape = F) %>% 
  kable_styling("striped", font_size = 9, full_width = F) %>% 
  scroll_box(width = "800px", height = "300px")
```
After the above mentioned things have been corrected (changing column names and adding NAs to the data) and reduendent columns have been dropped the dataset looks like the following,


```{r, warning=F, echo=F}

str_split(names(worldbank)," ")

i<-0
for (val in names(worldbank)){
  i<-i+1
  names(worldbank)[i] <- str_split(names(worldbank)[i]," ",simplify=TRUE)[1]
}
worldbank <- worldbank[,2:length(names(worldbank))]
names(worldbank)[3] <- 'Series Code'

worldbank <- worldbank %>% filter(Country == 'USA')

worldbank<-as.data.frame(worldbank)


for (name in names(worldbank)){
  for (row in row.names(worldbank)){
    if (worldbank[as.integer(row),name] == ".."){
      worldbank[as.integer(row),name] <- NA
    }
  }
}

drop <- c("Series Code","Country")

worldbank<-worldbank[,!(names(worldbank) %in% drop)]

write.csv(worldbank,'data/clean/clean_worldbank.csv',row.names = FALSE)

worldbank %>% kable(escape = F) %>% 
  kable_styling("striped", font_size = 9, full_width = F) %>% 
  scroll_box(width = "800px", height = "300px")
```

## EIA Data
### Corrections
There were several issues with the EIA data. First, the state name read in as "USA-<state>" (examples below).

```{r, warning=F, echo=F}
df <- read.csv('data/raw/monthly_fuel_generation_by_state_full.csv')
unique(df$state)[1:5]

```

We updated this column by splitting on the "-" delimiter and only keeping the actual state name. 

```{r, warning=F, echo=F}
df <- df %>% separate(state, sep = "-", into = c('country','state'), remove = TRUE)
df$country <- NULL
unique(df$state)[1:5]
```

Other formatting issues existed with the fuel type. There was white space at the start and end of each fuel and some fuels had a space in the middle of it (i.e. natural gas ) which is shown below. 

```{r, warning=F, echo=F}
unique(df$fuel)[1:5]
```

To make these variables easier to work with, we trimmed the white space at the beginning and end of the fuels and added an underscore if there was a space in the middle of the fuel type. A sample of the updated fuels is shown below:

```{r, warning=F, echo=F}
df$fuel <- trimws(df$fuel) 
df$fuel <- gsub(" ", "_", df$fuel)
df$fuel <- gsub("-", "_", df$fuel)
unique(df$fuel)[1:5]
```

The "date" column of the data was imported as a character column, so we updated it to be a date datatype.

```{r, warning=F, echo=F}
df$date <- as.Date(df$date)
```

Lastly, there was an issue where the solar generation total was not aggregated correctly on the EIA website. This is detailed more in the [missing values chapter](https://edav-ccfall21-final-project-team-7.github.io/USCleanEnergyAnalysis/missing-values.html). To fix this, we performed a pivot on the data and recalculated the aggregation, ignoring N/a's in the data. We also imputed zero for other values of the power generation so that aggregations were not affected in later code. 

```{r, warning=F, echo=F}
df[is.na(df$thousand_megawatthours),]$thousand_megawatthours <- 0
#Update solar summation to be correct
df <- df %>% pivot_wider(id_cols = c(date, state), names_from=c(fuel), values_from = thousand_megawatthours)
df <- df %>% rowwise() %>% mutate(all_solar = sum(small_scale_solar_photovoltaic, all_utility_scale_solar, na.rm = TRUE))
df <- df %>% pivot_longer(cols=names(df)[3:21],  names_to='fuel', values_to='thousand_megawatthours')
df[is.na(df$thousand_megawatthours),]$thousand_megawatthours <- 0

# i<-0
# for (vals in row.names(df)) {
#   i<-i+1
#   df$state[i] <- str_split(df$state[i],"-",simplify=TRUE)[2]
# }

write.csv(df,'data/clean/clean_monthly_fuel_generation.csv',row.names = FALSE)
```

### Create interactive data

The data needs to be transformed for the interactive component of this project. The data is wrangled to create a dataframe that contains each the percent of each fuel type used by each state on each date. 

```{r, warning=F, echo=F}
df <- read.csv('data/clean/clean_monthly_fuel_generation.csv')
interactive_data <- df %>% group_by(state, fuel, date) %>% pivot_wider(id_cols = c(state, date), names_from= fuel, values_from = thousand_megawatthours)
interactive_data[is.na(interactive_data)] <- 0
interactive_data <- interactive_data[names(interactive_data) %in% c('state', 'date', 'coal', 'petroleum_liquids','petroleum_coke','natural_gas', 'other_gases', 'nuclear', 'conventional_hydroelectric', 'other', 'other_renewables_(total)')]
interactive_data_percent <- interactive_data %>%
  gather(variable, value, -c(state,date)) %>%
  group_by(state,date) %>%
  mutate(percentage = value/sum(value, na.rm=TRUE)*100) %>%
  select(-value) %>%
  spread(variable, percentage)
interactive_data_percent$renewables <- interactive_data_percent$conventional_hydroelectric + interactive_data_percent$`other_renewables_(total)`
write.csv(interactive_data_percent, 'data/clean/interactive_data.csv',row.names = FALSE)
```

